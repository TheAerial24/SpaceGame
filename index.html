<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lite Spaceflight Sim - Phase 4.1 (Fix)</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
        }
        #hud {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 16px;
            z-index: 10;
            text-shadow: 1px 1px 2px black;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="hud">
        Altitude: 0 m<br>
        Velocity: 0 m/s<br>
        Time Warp: 1x
    </div>

    <script>
        // --- 1. SETUP (Untouched) ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const hud = document.getElementById('hud');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // --- 2. PHYSICS & SCALING (Untouched) ---
        const GM_EARTH = 3.986004418e14 / 16.0;
        const GM_MOON = 4.9048695e12 / 16.0;
        const EARTH_RADIUS = 6371000 / 4;
        const MOON_RADIUS = 1737000 / 4;
        const MOON_DISTANCE = 384400000 / 4;
        const SHIP_THRUST_ACCEL = 25.0;
        const SHIP_ROTATION_SPEED = 90.0;
        const SHIP_HEIGHT = 10;
        const SHIP_WIDTH = 5;
        const SAFE_LANDING_SPEED = 5.0;
        const MAX_ZOOM = 1.0;
        const MIN_ZOOM = 0.0000001;

        // --- 3. GAME OBJECTS (Untouched) ---
        let ship = {}; 
        const earth = {
            x: 0, y: 0,
            radius: EARTH_RADIUS,
            gm: GM_EARTH
        };
        const moon = {
            x: MOON_DISTANCE, y: 0,
            radius: MOON_RADIUS,
            gm: GM_MOON
        };
        const camera = {
            x: 0,
            y: 0,
            zoom: 0.0002
        };

        // --- 4. CONTROLS & TIME (Untouched) ---
        const keys = {
            ArrowUp: false,
            ArrowLeft: false,
            ArrowRight: false,
            '=': false,
            '-': false,
            '[': false,
            ']': false,
        };
        const timeWarpLevels = [1, 5, 10, 50, 100, 500, 1000, 10000];
        let timeWarpIndex = 0;
        let lastTime = 0; 
        window.addEventListener('keydown', (e) => {
            if (e.key in keys) keys[e.key] = true;
            if (e.key === ']') {
                timeWarpIndex = Math.min(timeWarpIndex + 1, timeWarpLevels.length - 1);
            }
            if (e.key === '[') {
                timeWarpIndex = Math.max(timeWarpIndex - 1, 0);
            }
        });
        window.addEventListener('keyup', (e) => {
            if (e.key in keys) keys[e.key] = false;
        });

        // --- 5. PHYSICS & GAME LOGIC (Untouched) ---

        function applyGravity(ship, body, dt) {
            // UNTOUCHED
            const dx = body.x - ship.x;
            const dy = body.y - ship.y;
            const distSq = dx * dx + dy * dy;
            const dist = Math.sqrt(distSq);
            
            const accel = body.gm / distSq;
            const ax = (dx / dist) * accel;
            const ay = (dy / dist) * accel;

            ship.vx += ax * dt;
            ship.vy += ay * dt;
            
            return dist; 
        }

        // --- THIS IS THE TRAJECTORY-ONLY FUNCTION ---
        function getGravityAccel(ghostShip, body) {
            const dx = body.x - ghostShip.x;
            const dy = body.y - ghostShip.y;
            const distSq = dx * dx + dy * dy;
            const dist = Math.sqrt(distSq);
            
            // --- FIX: REMOVED the crash check ---
            // if (dist < body.radius) { return null; } 
            // Now it will draw "through" the planet
            
            const accel = body.gm / distSq;
            const ax = (dx / dist) * accel;
            const ay = (dy / dist) * accel;
            
            return { ax, ay };
        }
        // ----------------------------------------

        function checkLanding(ship, body, dist, dt) {
            // UNTOUCHED
            if (dist < (body.radius + SHIP_HEIGHT / 2)) {
                const totalVelocity = Math.sqrt(ship.vx * ship.vx + ship.vy * ship.vy);
                
                if (totalVelocity > SAFE_LANDING_SPEED) {
                    console.log("CRASH! Speed: " + totalVelocity);
                    resetShip();
                } else {
                    landShip(ship, body);
                }
            }
        }
        
        function landShip(ship, body) {
            // UNTOUCHED
            ship.landedOn = body;
            ship.vx = 0;
            ship.vy = 0;
            
            const angleToBody = Math.atan2(ship.y - body.y, ship.x - body.x);
            
            const landRadius = body.radius + (SHIP_HEIGHT / 2);
            ship.x = body.x + Math.cos(angleToBody) * landRadius;
            ship.y = body.y + Math.sin(angleToBody) * landRadius;
            
            ship.angle = angleToBody + Math.PI / 2;
        }

        function resetShip() {
            // UNTOUCHED
            ship = {
                x: 0,
                y: -EARTH_RADIUS,
                vx: 0,
                vy: 0,
                angle: 0, 
                isThrusting: false,
                landedOn: null
            };
            landShip(ship, earth); 
            timeWarpIndex = 0;
        }

        // --- 6. UPDATE FUNCTION (Untouched) ---
        function update(dt) {
            // UNTOUCHED
            if (keys['=']) camera.zoom *= 1.02;
            if (keys['-']) camera.zoom /= 1.02;
            camera.zoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, camera.zoom));

            if (ship.landedOn) {
                // Landed controls
                if (keys.ArrowLeft) {
                    ship.angle -= (SHIP_ROTATION_SPEED * Math.PI / 180) * dt;
                }
                if (keys.ArrowRight) {
                    ship.angle += (SHIP_ROTATION_SPEED * Math.PI / 180) * dt;
                }
                
                ship.isThrusting = false;
                if (keys.ArrowUp) {
                    ship.landedOn = null; 
                    ship.isThrusting = true;
                    const accel_x = Math.cos(ship.angle - Math.PI / 2) * SHIP_THRUST_ACCEL;
                    const accel_y = Math.sin(ship.angle - Math.PI / 2) * SHIP_THRUST_ACCEL;
                    ship.vx += accel_x * dt;
                    ship.vy += accel_y * dt;
                }
            } else {
                // IN-FLIGHT LOGIC
                if (keys.ArrowLeft) {
                    ship.angle -= (SHIP_ROTATION_SPEED * Math.PI / 180) * dt;
                }
                if (keys.ArrowRight) {
                    ship.angle += (SHIP_ROTATION_SPEED * Math.PI / 180) * dt;
                }
                ship.isThrusting = false;
                if (keys.ArrowUp) {
                    ship.isThrusting = true;
                    const accel_x = Math.cos(ship.angle - Math.PI / 2) * SHIP_THRUST_ACCEL;
                    const accel_y = Math.sin(ship.angle - Math.PI / 2) * SHIP_THRUST_ACCEL;
                    ship.vx += accel_x * dt;
                    ship.vy += accel_y * dt;
                }
                let distToEarth = applyGravity(ship, earth, dt);
                let distToMoon = applyGravity(ship, moon, dt);
                ship.x += ship.vx * dt;
                ship.y += ship.vy * dt;
                checkLanding(ship, earth, distToEarth, dt);
                checkLanding(ship, moon, distToMoon, dt);
            }
            let distToEarthCenter = Math.sqrt(Math.pow(ship.x - earth.x, 2) + Math.pow(ship.y - earth.y, 2));
            let altitude = (distToEarthCenter - earth.radius).toFixed(0);
            let velocity = Math.sqrt(ship.vx * ship.vx + ship.vy * ship.vy).toFixed(2);
            hud.innerHTML = `Altitude (Earth): ${altitude} m<br>Velocity: ${velocity} m/s<br>Time Warp: ${timeWarpLevels[timeWarpIndex]}x`;
        }
        
        // --- TRAJECTORY FUNCTION ---
        
        // --- FIX: Reduced steps to fix lag ---
        const PREDICTION_STEPS = 100; // Was 500
        const PREDICTION_STEP_TIME = 5; 
        
        function drawTrajectory(ctx, ship) {
            // UNTOUCHED
            if (ship.landedOn) {
                return;
            }
            let ghost = {
                x: ship.x,
                y: ship.y,
                vx: ship.vx,
                vy: ship.vy
            };
            let pathPoints = [];

            for (let i = 0; i < PREDICTION_STEPS; i++) {
                let accelE = getGravityAccel(ghost, earth);
                let accelM = getGravityAccel(ghost, moon);
                
                // --- FIX: This check is now safe, as accel is never null ---
                let ax = accelE.ax + accelM.ax;
                let ay = accelE.ay + accelM.ay;
                
                ghost.vx += ax * PREDICTION_STEP_TIME;
                ghost.vy += ay * PREDICTION_STEP_TIME;
                ghost.x += ghost.vx * PREDICTION_STEP_TIME;
                ghost.y += ghost.vy * PREDICTION_STEP_TIME;
                
                pathPoints.push({ x: ghost.x, y: ghost.y });
            }
            
            ctx.beginPath();
            ctx.moveTo(ship.x, ship.y);
E           for (const point of pathPoints) {
                ctx.lineTo(point.x, point.y);
            }
            
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 1 / camera.zoom;
            ctx.stroke();
        }
        // ---------------------------------

        // --- 7. DRAW FUNCTION (Untouched) ---
        function draw() {
            // UNTOUCHED
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(camera.zoom, camera.zoom);
            camera.x = ship.x;
            camera.y = ship.y;
            ctx.translate(-camera.x, -camera.y);
            
            // Call to trajectory function (this is where it's drawn)
            drawTrajectory(ctx, ship);
            
            // Draw Earth
            ctx.beginPath();
            ctx.arc(earth.x, earth.y, earth.radius, 0, Math.PI * 2);
            ctx.fillStyle = '#3a86ff'; 
            ctx.fill();

            // Draw Moon
            ctx.beginPath();
            ctx.arc(moon.x, moon.y, moon.radius, 0, Math.PI * 2);
            ctx.fillStyle = '#8e9aaf';
            ctx.fill();

            // Draw the Ship
            ctx.save();
            ctx.translate(ship.x, ship.y);
            ctx.rotate(ship.angle); 
            ctx.lineWidth = 1 / camera.zoom; 
            ctx.beginPath();
            ctx.moveTo(0, -SHIP_HEIGHT / 2);
            ctx.lineTo(SHIP_WIDTH / 2, SHIP_HEIGHT / 2);
            ctx.lineTo(-SHIP_WIDTH / 2, SHIP_HEIGHT / 2);
            ctx.closePath();
            ctx.strokeStyle = 'white';
            ctx.stroke();
            if (ship.isThrusting) {
                ctx.beginPath();
                ctx.moveTo(0, SHIP_HEIGHT / 2);
                ctx.lineTo(-SHIP_WIDTH / 2, SHIP_HEIGHT / 2 + 7);
                ctx.lineTo(SHIP_WIDTH / 2, SHIP_HEIGHT / 2 + 7);
                ctx.closePath();
                ctx.fillStyle = 'orange';
                ctx.fill();
            }
            ctx.restore(); 
            ctx.restore(); 
        }

        // --- 8. GAME LOOP (Untouched) ---
        function gameLoop(timestamp) {
            // UNTOUCHED
            let dt = (timestamp - lastTime) / 1000;
            lastTime = timestamp;
            
            if (dt > 0.1) dt = 0.1; 
            
            let warpedDt = dt * timeWarpLevels[timeWarpIndex];
            
            let steps = Math.min(100, Math.max(1, warpedDt / 0.016)); 
            let stepDt = warpedDt / steps;
            
            for (let i = 0; i < steps; i++) {
                update(stepDt);
            }
            
            draw();
            requestAnimationFrame(gameLoop);
        }

        // --- START THE GAME (Untouched) ---
        resetShip(); 
        lastTime = performance.now(); 
        requestAnimationFrame(gameLoop); 

    </script>
</body>
</html>
