<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lite Spaceflight Sim - Phase 3.1</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
        }
        #hud {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 16px;
            z-index: 10;
            text-shadow: 1px 1px 2px black;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="hud">
        Altitude: 0 m<br>
        Velocity: 0 m/s<br>
        Time Warp: 1x
    </div>

    <script>
        // --- 1. SETUP ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const hud = document.getElementById('hud');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // --- 2. REAL-WORLD PHYSICS & SFS SCALING ---
        const GM_EARTH = 3.986004418e14; // m^3/s^2
        const GM_MOON = 4.9048695e12; // m^3/s^2

        const EARTH_RADIUS = 6371000 / 4; // 1,592,750 m
        const MOON_RADIUS = 1737000 / 4;  // 434,250 m
        const MOON_DISTANCE = 384400000 / 4; // 96,100,000 m

        const SHIP_THRUST_ACCEL = 25.0; // m/s^2
        const SHIP_ROTATION_SPEED = 3.0; // degrees per second
        const SHIP_HEIGHT = 10; // meters
        const SHIP_WIDTH = 5;   // meters
        const SAFE_LANDING_SPEED = 5.0; // m/s
        
        // --- FIX: ZOOM LIMITS ---
        const MAX_ZOOM = 1.0;     // 1 pixel = 1 meter
        const MIN_ZOOM = 0.0000001; // 1 pixel = 10,000,000 meters

        // --- 3. GAME OBJECTS (Positions in METERS) ---
        let ship = {};
        const earth = {
            x: 0, y: 0,
            radius: EARTH_RADIUS,
            gm: GM_EARTH
        };
        const moon = {
            x: MOON_DISTANCE, y: 0,
            radius: MOON_RADIUS,
            gm: GM_MOON
        };

        const camera = {
            x: 0,
            y: 0,
            zoom: 0.0002 // 1 pixel = 5000 meters (Good starting zoom)
        };

        // --- 4. CONTROLS & TIME ---
        const keys = {
            ArrowUp: false,
            ArrowLeft: false,
            ArrowRight: false,
            '=': false, // Zoom in
            '-': false, // Zoom out
            '[': false, // Time warp down
            ']': false, // Time warp up
        };

        const timeWarpLevels = [1, 5, 10, 50, 100, 500, 1000, 10000];
        let timeWarpIndex = 0;
        let lastTime = 0; 

        window.addEventListener('keydown', (e) => {
            if (e.key in keys) keys[e.key] = true;
            if (e.key === ']') {
                timeWarpIndex = Math.min(timeWarpIndex + 1, timeWarpLevels.length - 1);
            }
            if (e.key === '[') {
                timeWarpIndex = Math.max(timeWarpIndex - 1, 0);
            }
        });
        window.addEventListener('keyup', (e) => {
            if (e.key in keys) keys[e.key] = false;
        });

        // --- 5. PHYSICS & GAME LOGIC ---

        function applyGravity(ship, body, dt) {
            const dx = body.x - ship.x;
            const dy = body.y - ship.y;
            const distSq = dx * dx + dy * dy;
            const dist = Math.sqrt(distSq);
            
            // a = GM / r^2
            const accel = body.gm / distSq;
            
            const ax = (dx / dist) * accel;
            const ay = (dy / dist) * accel;

            ship.vx += ax * dt;
            ship.vy += ay * dt;
            
            return dist; 
        }

        function checkLanding(ship, body, dist, dt) {
            if (dist < body.radius) {
                const totalVelocity = Math.sqrt(ship.vx * ship.vx + ship.vy * ship.vy);
                
                if (totalVelocity > SAFE_LANDING_SPEED) {
                    console.log("CRASH! Speed: " + totalVelocity);
                    resetShip();
                } else {
                    landShip(ship, body);
                }
            }
        }
        
        function landShip(ship, body) {
            ship.landedOn = body;
            ship.vx = 0;
            ship.vy = 0;
            
            // "Stick" ship to surface and set correct angle
            const angleToBody = Math.atan2(ship.y - body.y, ship.x - body.x);
            ship.x = body.x + Math.cos(angleToBody) * body.radius;
            ship.y = body.y + Math.sin(angleToBody) * body.radius;
            // --- FIX: Point ship "up" away from the planet center ---
            ship.angle = angleToBody - Math.PI / 2;
        }

        function resetShip() {
            ship = {
                x: 0,
                y: -EARTH_RADIUS, // Start ON the Earth's surface
                vx: 0,
                vy: 0,
                // --- FIX: Start angle 0 (points "up" along -Y axis) ---
                angle: 0, 
                isThrusting: false,
                landedOn: null // Will be set by checkLanding on first frame
            };
            timeWarpIndex = 0;
        }

        // --- 6. UPDATE FUNCTION ---
        function update(dt) {
            // Handle Zoom
            // --- FIX: Clamp zoom levels ---
            if (keys['=']) camera.zoom *= 1.02; // Zoom in
            if (keys['-']) camera.zoom /= 1.02; // Zoom out
            camera.zoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, camera.zoom));

            if (ship.landedOn) {
                // --- FIX: Correct rotation direction ---
                if (keys.ArrowLeft) { // Counter-clockwise
                    ship.angle -= (SHIP_ROTATION_SPEED * Math.PI / 180) * dt;
                }
                if (keys.ArrowRight) { // Clockwise
                    ship.angle += (SHIP_ROTATION_SPEED * Math.PI / 180) * dt;
                }
                ship.isThrusting = false;
                if (keys.ArrowUp) {
                    // TAKEOFF
                    ship.landedOn = null; 
                    ship.isThrusting = true;
                    // --- FIX: Correct thrust logic ---
                    // sin(angle) for X, -cos(angle) for Y
                    const accel_x = Math.sin(ship.angle) * SHIP_THRUST_ACCEL;
                    const accel_y = -Math.cos(ship.angle) * SHIP_THRUST_ACCEL;
                    ship.vx += accel_x * dt;
                    ship.vy += accel_y * dt;
                }
            } else {
                // --- IN-FLIGHT LOGIC ---
                
                // --- FIX: Correct rotation direction ---
                if (keys.ArrowLeft) {
                    ship.angle -= (SHIP_ROTATION_SPEED * Math.PI / 180) * dt;
                }
                if (keys.ArrowRight) {
                    ship.angle += (SHIP_ROTATION_SPEED * Math.PI / 180) * dt;
                }

                ship.isThrusting = false;
                if (keys.ArrowUp) {
                    ship.isThrusting = true;
                    // --- FIX: Correct thrust logic ---
                    const accel_x = Math.sin(ship.angle) * SHIP_THRUST_ACCEL;
                    const accel_y = -Math.cos(ship.angle) * SHIP_THRUST_ACCEL;
                    ship.vx += accel_x * dt;
                    ship.vy += accel_y * dt;
                }

                // Apply Physics
                let distToEarth = applyGravity(ship, earth, dt);
                let distToMoon = applyGravity(ship, moon, dt);
                
                ship.x += ship.vx * dt;
                ship.y += ship.vy * dt;

                // Check for landing/crashing
                checkLanding(ship, earth, distToEarth, dt);
                checkLanding(ship, moon, distToMoon, dt);
            }

            // Update HUD
            let altitude = (Math.sqrt(Math.pow(ship.x - earth.x, 2) + Math.pow(ship.y - earth.y, 2)) - earth.radius).toFixed(0);
            let velocity = Math.sqrt(ship.vx * ship.vx + ship.vy * ship.vy).toFixed(2);
            hud.innerHTML = `Altitude (Earth): ${altitude} m<br>Velocity: ${velocity} m/s<br>Time Warp: ${timeWarpLevels[timeWarpIndex]}x`;
        }

        // --- 7. DRAW FUNCTION ---
        function draw() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // --- CAMERA ---
            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(camera.zoom, camera.zoom);
            
            // Center camera on ship
            camera.x = ship.x;
            camera.y = ship.y;
            ctx.translate(-camera.x, -camera.y);

            // --- DRAW OBJECTS (in METERS) ---
            
            // Draw Earth
            ctx.beginPath();
            ctx.arc(earth.x, earth.y, earth.radius, 0, Math.PI * 2);
            ctx.fillStyle = '#3a86ff'; 
            ctx.fill();

            // Draw Moon
            ctx.beginPath();
            ctx.arc(moon.x, moon.y, moon.radius, 0, Math.PI * 2);
            ctx.fillStyle = '#8e9aaf';
            ctx.fill();

            // Draw the Ship
            ctx.save();
            ctx.translate(ship.x, ship.y);
            ctx.rotate(ship.angle);
            
            // This line width is now safe because zoom is clamped
            ctx.lineWidth = 1 / camera.zoom; 
            
            // Draw ship model (points "up")
            ctx.beginPath();
            ctx.moveTo(0, -SHIP_HEIGHT / 2); // Nose
            ctx.lineTo(SHIP_WIDTH / 2, SHIP_HEIGHT / 2); // Back-right
            ctx.lineTo(-SHIP_WIDTH / 2, SHIP_HEIGHT / 2); // Back-left
            ctx.closePath();
            ctx.strokeStyle = 'white';
            ctx.stroke();

            // Draw thruster flame
            if (ship.isThrusting) {
                ctx.beginPath();
                ctx.moveTo(0, SHIP_HEIGHT / 2);
                ctx.lineTo(-SHIP_WIDTH / 2, SHIP_HEIGHT / 2 + 7); // 7m long flame
                ctx.lineTo(SHIP_WIDTH / 2, SHIP_HEIGHT / 2 + 7);
                ctx.closePath();
                ctx.fillStyle = 'orange';
                ctx.fill();
            }
            ctx.restore(); // Restore from ship's rotation
            
            ctx.restore(); // Restore from camera
        }

        // --- 8. GAME LOOP ---
        function gameLoop(timestamp) {
            let dt = (timestamp - lastTime) / 1000;
            lastTime = timestamp;
            
            if (dt > 0.1) dt = 0.1; 
            
            let warpedDt = dt * timeWarpLevels[timeWarpIndex];
            
            let steps = Math.min(100, Math.max(1, warpedDt / 0.016)); 
            let stepDt = warpedDt / steps;
            
            for (let i = 0; i < steps; i++) {
                update(stepDt);
            }
            
            draw();
            requestAnimationFrame(gameLoop);
        }

        // --- START THE GAME ---
        resetShip(); 
        lastTime = performance.now(); 
        requestAnimationFrame(gameLoop); 

    </script>
</body>
</html>
