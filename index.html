<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spaceflight Simulator Lite</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
        }
        #hud {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 16px;
            z-index: 10;
            text-shadow: 1px 1px 2px black;
        }
        
        #saveControls {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 10;
            display: flex; /* Aligns buttons horizontally */
            gap: 10px; /* Adds space between buttons */
        }
        #saveControls button {
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 14px;
            background-color: #333;
            color: white;
            border: 1px solid white;
            padding: 5px 10px;
            cursor: pointer;
        }
        #saveControls button:hover {
            background-color: #555;
        }

        /* --- Achievement Notification Pop-up (Untouched) --- */
        #notification-box {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: #28a745; /* Green */
            color: white;
            font-family: 'Consolas', 'Courier New', monospace;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s, visibility 0.5s, transform 0.5s;
            transform: translateY(20px);
        }
        #notification-box.show {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }
        #notification-box h4 {
            margin: 0 0 5px 0;
            font-size: 16px;
        }
        #notification-box p {
            margin: 0;
            font-size: 14px;
        }

        /* --- Achievement Modal (List) (Untouched) --- */
        #modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 998;
            display: none;
        }
        #achievements-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 500px;
            background-color: #222;
            color: white;
            font-family: 'Consolas', 'Courier New', monospace;
            border: 1px solid white;
            border-radius: 8px;
            z-index: 999;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            display: none;
        }
        #achievements-modal h2 {
            text-align: center;
            border-bottom: 1px solid #444;
            padding: 15px;
            margin: 0;
        }
        #achievements-modal ul {
            list-style: none;
            padding: 20px;
            margin: 0;
            max-height: 300px;
            overflow-y: auto;
        }
        #achievements-modal li {
            font-size: 16px;
            margin-bottom: 12px;
            opacity: 0.6;
        }
        #achievements-modal li.unlocked {
            opacity: 1;
            color: #28a745; /* Green */
        }
        #achievements-modal li span {
            display: block;
            font-size: 14px;
            color: #ccc;
            padding-left: 28px;
        }
        #achievements-modal li.unlocked span {
            color: #aaa;
        }
        #achievements-modal button {
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 14px;
            background-color: #555;
            color: white;
            border: none;
            padding: 10px 15px;
            cursor: pointer;
            width: 100%;
            border-top: 1px solid #444;
            border-bottom-left-radius: 7px;
            border-bottom-right-radius: 7px;
        }
        #achievements-modal button:hover {
            background-color: #777;
        }

    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="hud">
        Altitude: 0 m<br>
        Velocity: 0 m/s<br>
        <br>
        Apoapsis: 0 m<br>
        Periapsis: 0 m<br>
        <br>
        Time Warp: 1x
    </div>
    
    <div id="saveControls">
        <button id="viewAchievementsButton">View Achievements</button>
        <button id="saveButton">Save Game</button>
        <button id="loadButton">Load Game</button>
    </div>

    <div id="notification-box">
        <h4>Achievement Unlocked!</h4>
        <p>You landed on the Moon!</p>
    </div>

    <div id="modal-overlay"></div>
    <div id="achievements-modal">
        <h2>Achievements</h2>
        <ul id="achievement-list">
            </ul>
        <button id="closeModalButton">Close</button>
    </div>


    <script>
        // --- 1. SETUP ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const hud = document.getElementById('hud');
        
        const saveButton = document.getElementById('saveButton');
        const loadButton = document.getElementById('loadButton');

        // Get references to new UI elements
        const notificationBox = document.getElementById('notification-box');
        const modalOverlay = document.getElementById('modal-overlay');
        const achievementsModal = document.getElementById('achievements-modal');
        const viewAchievementsButton = document.getElementById('viewAchievementsButton');
        const closeModalButton = document.getElementById('closeModalButton');
        const achievementList = document.getElementById('achievement-list');
        
        let notificationTimer = null;

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // --- 2. PHYSICS & SCALING (Untouched) ---
        const GM_EARTH = 3.986004418e14 / 16.0;
        const GM_MOON = 4.9048695e12 / 16.0;
        const EARTH_RADIUS = 6371000 / 4;
        const MOON_RADIUS = 1737000 / 4;
        const MOON_DISTANCE = (384400000 / 4) / 2;
        const SHIP_THRUST_ACCEL = 25.0;
        const SHIP_ROTATION_SPEED = 90.0;
        const SHIP_HEIGHT = 10;
        const SHIP_WIDTH = 5;
        const SAFE_LANDING_SPEED = 20.0;
        const MAX_ZOOM = 1.0;
        const MIN_ZOOM = 0.0000001;

        // --- 3. GAME OBJECTS (Untouched) ---
        let ship = {}; 
        const earth = {
            x: 0, y: 0,
            radius: EARTH_RADIUS,
            gm: GM_EARTH
        };
        const moon = {
            x: MOON_DISTANCE, y: 0,
            radius: MOON_RADIUS,
            gm: GM_MOON
        };
        const camera = {
            x: 0,
            y: 0,
            zoom: 0.0002
        };
        let trajectory = {
            path: [],
            apoapsis: 0,
            periapsis: 0
        };
        let isMapView = false;
        let historyLog = [];
        let lastHistorySave = 0;

        // --- MODIFIED: Achievement Tracking Variable ---
        let hasLandedOnMoon = false; // This is now loaded from localStorage

        // --- 4. CONTROLS & TIME (Untouched) ---
        const keys = {
            ArrowUp: false,
            ArrowLeft: false,
            ArrowRight: false,
            '=': false,
            '-': false,
            '[': false,
            ']': false,
            'm': false,
            'r': false,
        };
        const timeWarpLevels = [1, 5, 10, 50, 100, 500, 1000, 10000];
        let timeWarpIndex = 0;
        let lastTime = 0; 
        
        window.addEventListener('keydown', (e) => {
            if (e.key in keys) keys[e.key] = true;
            if (e.key === ']') {
                timeWarpIndex = Math.min(timeWarpIndex + 1, timeWarpLevels.length - 1);
            }
            if (e.key === '[') {
                timeWarpIndex = Math.max(timeWarpIndex - 1, 0);
            }
        });
        
        window.addEventListener('keyup', (e) => {
            if (e.key in keys) keys[e.key] = false;
            if (e.key === 'm' || e.key === 'M') {
                isMapView = !isMapView; 
            }
            if (e.key === 'r' || e.key === 'R') {
                if (historyLog.length > 0) {
                    console.log("Rewinding 10 seconds!");
                    ship = JSON.parse(JSON.stringify(historyLog[0]));
                    historyLog = [];
                    trajectory.path = [];
                    timeWarpIndex = 0;
                } else {
                    console.log("History log is empty.");
                }
            }
        });

        // --- 5. PHYSICS & GAME LOGIC ---

        const SAVE_KEY = "sfs_lite_savegame";

        // --- Achievement System Definition (Untouched) ---
        const achievements = {
            'orbit': {
                name: "Stable Orbit",
                description: "Achieve a stable orbit with a periapsis above 0m.",
                unlocked: false,
                check: (ship, trajectory) => {
                    return !ship.landedOn && trajectory.periapsis > 0;
                }
            },
            'highAltitude': {
                name: "High Flyer",
                description: "Reach an altitude of over 1,000,000m.",
                unlocked: false,
                check: (ship, trajectory) => {
                    let distToEarthCenter = Math.sqrt(Math.pow(ship.x - earth.x, 2) + Math.pow(ship.y - earth.y, 2));
                    let altitude = distToEarthCenter - earth.radius;
                    return altitude > 1000000;
                }
            },
            'highSpeed': { 
                name: "Speed Demon",
                description: "Exceed a velocity of 2000 m/s.",
                unlocked: false,
                check: (ship, trajectory) => {
                    const velocity = Math.sqrt(ship.vx * ship.vx + ship.vy * ship.vy);
                    return velocity > 2000;
                }
            },
            'moonLanding': {
                name: "One Small Step",
                description: "Land on the Moon.",
                unlocked: false,
                check: (ship, trajectory) => {
                    return ship.landedOn === moon;
                }
            },
            'moonAndBack': { 
                name: "There and Back Again",
                description: "Land on the Moon and return safely to Earth.",
                unlocked: false,
                check: (ship, trajectory) => {
                    return hasLandedOnMoon && ship.landedOn === earth;
                }
            }
        };

        // --- Notification Pop-up Function (Untouched) ---
        function showNotification(name, description) {
            if (notificationTimer) {
                clearTimeout(notificationTimer);
            }
            notificationBox.innerHTML = `<h4>${name}</h4><p>${description}</p>`;
            notificationBox.classList.add('show');
            notificationTimer = setTimeout(() => {
                notificationBox.classList.remove('show');
                notificationTimer = null;
            }, 4000);
        }

        // --- NEW: Function to safely get save data ---
        function getSaveState() {
            const saveString = localStorage.getItem(SAVE_KEY);
            if (saveString) {
                try {
                    // Try to parse the saved string
                    return JSON.parse(saveString);
                } catch (e) {
                    // If it's corrupted, return a new empty object
                    console.error("Could not parse save file, creating new one.", e);
                    return {};
                }
            }
            // If no save string exists, return a new empty object
            return {};
        }

        // --- NEW: Function to save achievement data automatically ---
        function saveAchievements() {
            // 1. Get the current, valid save state
            let saveState = getSaveState();
            
            // 2. Build the achievement state
            let achievementsState = {};
            for (const id in achievements) {
                achievementsState[id] = achievements[id].unlocked;
            }

            // 3. Update the save state with new achievement data
            saveState.achievements = achievementsState;
            saveState.hasLandedOnMoon = hasLandedOnMoon;

            // 4. Save back to localStorage
            localStorage.setItem(SAVE_KEY, JSON.stringify(saveState));
            console.log("Permanent achievement data saved!");
        }

        // --- NEW: Function to load achievements on game start ---
        function loadAchievements() {
            // 1. Get the current, valid save state
            const saveState = getSaveState();
                
            // 2. Load achievements
            if (saveState.achievements) {
                for (const id in saveState.achievements) {
                    if (achievements[id]) {
                        achievements[id].unlocked = saveState.achievements[id];
                    }
                }
            }
            
            // 3. Load moon landing flag
            if (saveState.hasLandedOnMoon) {
                hasLandedOnMoon = saveState.hasLandedOnMoon;
            }
            console.log("Permanent achievement data loaded!");
        }


        // --- MODIFIED: Achievement Checking Function ---
        function checkAchievements(ship, trajectory) {
            for (const id in achievements) {
                const achievement = achievements[id];
                
                if (!achievement.unlocked) {
                    if (achievement.check(ship, trajectory)) {
                        achievement.unlocked = true;
                        showNotification(achievement.name, achievement.description);
                        // --- NEW: Automatically save when one is unlocked ---
                        saveAchievements(); 
                    }
                }
            }
        }

        // --- Achievement Modal Function (Untouched) ---
        function toggleAchievementsModal(show) {
            if (show) {
                achievementList.innerHTML = ''; // Clear old list
                for (const id in achievements) {
                    const ach = achievements[id];
                    const li = document.createElement('li');
                    
                    if (ach.unlocked) {
                        li.classList.add('unlocked');
                        li.innerHTML = `[âœ”] ${ach.name}<span>${ach.description}</span>`;
                    } else {
                        li.innerHTML = `[ ] ${ach.name}<span>${ach.description}</span>`;
                    }
                    achievementList.appendChild(li);
                }
                modalOverlay.style.display = 'block';
                achievementsModal.style.display = 'block';
            } else {
                modalOverlay.style.display = 'none';
                achievementsModal.style.display = 'none';
            }
        }

        // --- MODIFIED: Save/Load Functions ---
        // SaveGame now ONLY saves the ship's position
        function saveGame() {
            if (ship.landedOn) {
                // 1. Get existing save data
                let saveState = getSaveState();
                
                // 2. Add/update the ship data
                saveState.ship = ship;
                
                // 3. Save back to localStorage
                localStorage.setItem(SAVE_KEY, JSON.stringify(saveState));
                showNotification("Game Saved", "Your ship's position has been saved.");
            } else {
                showNotification("Save Failed", "You can only save ship position while landed.");
            }
        }
        
        // LoadGame now ONLY loads the ship's position
        function loadGame() {
            // 1. Get existing save data
            const saveState = getSaveState();
                
            // 2. Check if ship data exists
            if (saveState.ship) {
                ship = saveState.ship;
                
                // Reset systems
                historyLog = [];
                trajectory.path = [];
                timeWarpIndex = 0;
                isMapView = false; 
                
                showNotification("Game Loaded", "Your ship's position has been loaded.");
            } else {
                showNotification("Load Failed", "No saved ship position found!");
            }
        }
        
        // --- Hook up buttons (Untouched) ---
        saveButton.addEventListener('click', saveGame);
        loadButton.addEventListener('click', loadGame);
        viewAchievementsButton.addEventListener('click', () => toggleAchievementsModal(true));
        closeModalButton.addEventListener('click', () => toggleAchievementsModal(false));
        modalOverlay.addEventListener('click', () => toggleAchievementsModal(false));


        // --- Gravity/Physics Functions (Untouched) ---

        function applyGravity(ship, body, dt) {
            const dx = body.x - ship.x;
            const dy = body.y - ship.y;
            const distSq = dx * dx + dy * dy;
            const dist = Math.sqrt(distSq);
            
            const accel = body.gm / distSq;
            const ax = (dx / dist) * accel;
            const ay = (dy / dist) * accel;

            ship.vx += ax * dt;
            ship.vy += ay * dt;
            
            return dist; 
        }

        function getGravityAccel(ghostShip, body) {
            const dx = body.x - ghostShip.x;
            const dy = body.y - ghostShip.y;
            const distSq = dx * dx + dy * dy;
            const dist = Math.sqrt(distSq);
            
            let radiusUsed = Math.max(dist, body.radius);
            let distSqUsed = radiusUsed * radiusUsed;
            
            const accel = body.gm / distSqUsed;
            const ax = (dx / dist) * accel;
            const ay = (dy / dist) * accel;
            
            return { ax, ay, dist };
        }

        function checkLanding(ship, body, dist, dt) {
            if (dist < (body.radius + SHIP_HEIGHT / 2)) {
                const totalVelocity = Math.sqrt(ship.vx * ship.vx + ship.vy * ship.vy);
                
                if (totalVelocity > SAFE_LANDING_SPEED) {
                    console.log("CRASH! Speed: " + totalVelocity);
                    resetShip(); // This will just reset the ship, not achievements
                } else {
                    landShip(ship, body);
                }
            }
        }
        
        // --- MODIFIED: landShip ---
        function landShip(ship, body) {
            ship.landedOn = body;
            ship.vx = 0;
            ship.vy = 0;
            
            const angleToBody = Math.atan2(ship.y - body.y, ship.x - body.x);
            const landRadius = body.radius + (SHIP_HEIGHT / 2);
            ship.x = body.x + Math.cos(angleToBody) * landRadius;
            ship.y = body.y + Math.sin(angleToBody) * landRadius;
            ship.angle = angleToBody + Math.PI / 2;

            if (body === moon) {
                // Check if this is the first time landing
                if (!hasLandedOnMoon) { 
                    hasLandedOnMoon = true;
                    // --- NEW: Automatically save this flag ---
                    saveAchievements(); 
                }
            }
        }

        // --- MODIFIED: resetShip ---
        function resetShip() {
            ship = {
                x: 0,
                y: -EARTH_RADIUS,
                vx: 0,
                vy: 0,
                angle: 0, 
                isThrusting: false,
                landedOn: null
            };
            landShip(ship, earth); 
            timeWarpIndex = 0;
            historyLog = [];
            
            // --- REMOVED ---
            // The loop that reset achievements is GONE.
            // `hasLandedOnMoon = false` is also GONE.
            // Achievements are now persistent.
        }

        // --- TRAJECTORY CALCULATION (Untouched) ---
        const PREDICTION_STEPS = 1000;
        const PREDICTION_STEP_TIME = 2;

        function calculateTrajectory(ship) {
            let ghost = {
                x: ship.x,
                y: ship.y,
                vx: ship.vx,
                vy: ship.vy
            };
            
            let pathPoints = [];
            let maxDist = 0;
            let minDist = Infinity;

            for (let i = 0; i < PREDICTION_STEPS; i++) {
                let accelE = getGravityAccel(ghost, earth);
                let accelM = getGravityAccel(ghost, moon);
                
                let ax = accelE.ax + accelM.ax;
                let ay = accelE.ay + accelM.ay;
                
                ghost.vx += ax * PREDICTION_STEP_TIME;
                ghost.vy += ay * PREDICTION_STEP_TIME;
                ghost.x += ghost.vx * PREDICTION_STEP_TIME;
                ghost.y += ghost.vy * PREDICTION_STEP_TIME;
                
                pathPoints.push({ x: ghost.x, y: ghost.y });
                
                maxDist = Math.max(maxDist, accelE.dist);
                minDist = Math.min(minDist, accelE.dist);
            }
            
            return {
                path: pathPoints,
                apoapsis: maxDist - earth.radius,
                periapsis: minDist - earth.radius
            };
        }

        // --- 6. UPDATE FUNCTION (This is the fixed version) ---
        function update(dt) {
            // --- Camera logic (Untouched) ---
            if (!isMapView) {
                if (keys['=']) camera.zoom *= 1.02;
                if (keys['-']) camera.zoom /= 1.02;
                camera.zoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, camera.zoom));
            } else {
                camera.zoom = 0.000005;
            }

            // --- Control logic ---
            if (ship.landedOn) {
                // LANDED CONTROLS
                if (keys.ArrowLeft) {
                    ship.angle -= (SHIP_ROTATION_SPEED * Math.PI / 180) * dt;
                }
                if (keys.ArrowRight) {
                    ship.angle += (SHIP_ROTATION_SPEED * Math.PI / 180) * dt;
                }
                
                ship.isThrusting = false;
                if (keys.ArrowUp) {
                    ship.landedOn = null; // Takeoff!
                    ship.isThrusting = true;
                    // Apply initial thrust
                    const accel_x = Math.cos(ship.angle - Math.PI / 2) * SHIP_THRUST_ACCEL;
                    const accel_y = Math.sin(ship.angle - Math.PI / 2) * SHIP_THRUST_ACCEL;
                    ship.vx += accel_x * dt;
                    ship.vy += accel_y * dt;
                }
            } else {
                // IN-FLIGHT CONTROLS
                if (keys.ArrowLeft) {
                    ship.angle -= (SHIP_ROTATION_SPEED * Math.PI / 180) * dt;
                }
                if (keys.ArrowRight) {
                    ship.angle += (SHIP_ROTATION_SPEED * Math.PI / 180) * dt;
                }
                ship.isThrusting = false;
                if (keys.ArrowUp) {
                    ship.isThrusting = true;
                    // Apply continuous thrust
                    const accel_x = Math.cos(ship.angle - Math.PI / 2) * SHIP_THRUST_ACCEL;
                    const accel_y = Math.sin(ship.angle - Math.PI / 2) * SHIP_THRUST_ACCEL;
                    ship.vx += accel_x * dt;
                    ship.vy += accel_y * dt;
                }
            }

            // --- PHYSICS & MOVEMENT (This logic is fixed) ---
            if (!ship.landedOn) {
                let distToEarth = applyGravity(ship, earth, dt);
                let distToMoon = applyGravity(ship, moon, dt);
                
                ship.x += ship.vx * dt;
                ship.y += ship.vy * dt;
                
                checkLanding(ship, earth, distToEarth, dt);
                checkLanding(ship, moon, distToMoon, dt);
            }
            
            // --- HUD & TRAJECTORY ---
            let altitude, velocity, apText, peText;
            let distToEarthCenter = Math.sqrt(Math.pow(ship.x - earth.x, 2) + Math.pow(ship.y - earth.y, 2));
            altitude = (distToEarthCenter - earth.radius).toFixed(0);
            velocity = Math.sqrt(ship.vx * ship.vx + ship.vy * ship.vy).toFixed(2);

            if (ship.landedOn) {
                apText = "Landed";
                peText = "Landed";
                trajectory.path = []; 
            } else {
                trajectory = calculateTrajectory(ship);
                apText = `${trajectory.apoapsis.toFixed(0)} m`;
                peText = `${trajectory.periapsis.toFixed(0)} m`;
            }
            
            // Check achievements
            checkAchievements(ship, trajectory);

            // HUD Display (Untouched)
            hud.innerHTML = `Altitude: ${altitude} m<br>Velocity: ${velocity} m/s<br><br>
                             Apoapsis: ${apText}<br>Periapsis: ${peText}<br><br>
                             Time Warp: ${timeWarpLevels[timeWarpIndex]}x`;
        }
        
        // --- 7. DRAW FUNCTION (Untouched) ---
        
        function drawTrajectory(ctx) {
            if (trajectory.path.length === 0) {
                return;
            }
            
            ctx.beginPath();
            ctx.moveTo(ship.x, ship.y); 
            for (const point of trajectory.path) {
                ctx.lineTo(point.x, point.y);
            }
            
            ctx.strokeStyle = 'rgba(255, 255, 250, 0.5)';
            ctx.lineWidth = 1 / camera.zoom;
            ctx.stroke();
        }

        function draw() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(camera.zoom, camera.zoom);

            if (!isMapView) {
                camera.x = ship.x;
                camera.y = ship.y;
            } else {
                camera.x = earth.x;
                camera.Y = earth.y;
            }
            ctx.translate(-camera.x, -camera.y);
            
            drawTrajectory(ctx);
            
            // Draw Earth
            ctx.beginPath();
            ctx.arc(earth.x, earth.y, earth.radius, 0, Math.PI * 2);
            ctx.fillStyle = '#3a86ff'; 
            ctx.fill();

            // Draw Moon
            ctx.beginPath();
            ctx.arc(moon.x, moon.y, moon.radius, 0, Math.PI * 2);
            ctx.fillStyle = '#8e9aaf';
            ctx.fill();

            // Draw the Ship
            ctx.save();
            ctx.translate(ship.x, ship.y);
            ctx.rotate(ship.angle); 
            ctx.lineWidth = 1 / camera.zoom; 
            ctx.beginPath();
            ctx.moveTo(0, -SHIP_HEIGHT / 2);
            ctx.lineTo(SHIP_WIDTH / 2, SHIP_HEIGHT / 2);
            ctx.lineTo(-SHIP_WIDTH / 2, SHIP_HEIGHT / 2);
            ctx.closePath();
            ctx.strokeStyle = 'white';
            ctx.stroke();
            if (ship.isThrusting) {
                ctx.beginPath();
                ctx.moveTo(0, SHIP_HEIGHT / 2);
                ctx.lineTo(-SHIP_WIDTH / 2, SHIP_HEIGHT / 2 + 7);
                ctx.lineTo(SHIP_WIDTH / 2, SHIP_HEIGHT / 2 + 7);
                ctx.closePath();
                ctx.fillStyle = 'orange';
                ctx.fill();
            }
            ctx.restore(); 
            ctx.restore();
        }

        // --- 8. GAME LOOP (TYPO FIXED) ---
        function gameLoop(timestamp) {
            
            if (timestamp - lastHistorySave > 100) {
                lastHistorySave = timestamp;
                historyLog.push(JSON.parse(JSON.stringify(ship)));
                if (historyLog.length > 100) {
                    historyLog.shift();
                }
            }
            
            let dt = (timestamp - lastTime) / 1000;
            lastTime = timestamp;
            
            if (dt > 0.1) dt = 0.1; 
            
            let warpedDt = dt * timeWarpLevels[timeWarpIndex];
            
            let steps = Math.min(100, Math.max(1, warpedDt / 0.016)); 
            let stepDt = warpedDt / steps;
            
            // --- THIS IS THE FIX ---
            // Changed "steps.length" to just "steps"
            for (let i = 0; i < steps; i++) {
                update(stepDt);
            }
            
            draw();
            requestAnimationFrame(gameLoop);
        }

        // --- MODIFIED: START THE GAME ---
        loadAchievements(); // Load permanent progress first
        resetShip();        // Reset the ship to the launchpad
        lastTime = performance.now(); 
        requestAnimationFrame(gameLoop); 

    </script>
</body>
</html>
